# Chapter 2

# insertion sort pseudo code to python.
def insertion_sort(A):
    for i in range(1, len(A)):
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] > key:
            A[j + 1], A[j] = A[j], key
            j -= 1
    return A


print(insertion_sort([5, 2, 3, 4]))


# 2.1-1
# Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the array A(31, 41, 59, 26, 41, 58)


# 2.1-2
# Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non- decreasing order.
def insertion_sort_nonincresing(A):
    for i in range(1, len(A)):
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] < key:
            A[j + 1], A[j] = A[j], key
            j -= 1
    return A


print(insertion_sort_nonincresing([5, 2, 3, 4]))


# 2.1-3
def linear_search(A, val):
    for i in range(len(A)):
        if A[i] == val:
            return A[i]

    return None


print(linear_search([5, 2, 3, 4], 4))


# 2.1-4
def add_2bin(A, B):
    # both A and B has the same length n
    C = []
    carry = 0
    for i in range(len(A) - 1, 0 - 1, -1):
        add = int(bin(A[i] + B[i] + carry)[2:])
        add = map(int, str(add))
        if len(add) > 1:
            carry = add[0]

        for x in range(len(add) - 1, 0 - 1, -1):
            C.insert(x, add[x])

    return C


print(add_2bin([1, 0], [1, 0]))


# 2.2-1 = n^3

# 2.2-2
def selection_sort(A):
    for i in range(len(A) - 1):
        smallest = A[i]
        for j in range(i + 1, len(A)):
            if A[j] < smallest:
                smallest = A[j]
                index_smallest = j
        A[i], A[index_smallest] = smallest, A[i]

    return A


# def selection_sort(A):
#     for i in range(len(A) - 1):
#         smallest = i
#         for j in range(i + 1, len(A)):
#             if A[j] < A[smallest]:
#                 smallest = j
#         A[i], A[smallest] = A[smallest], A[i]
#     return A


print(selection_sort([5, 4, 3, 2, 8, 0, 8, 11, 1]))


# # Why does it need to run for only the first n-1 elements, rather than for all n elements?
# # # Find the smallest number for each iteration in the second for loop. Eventually, the first loop has the last number as the biggest. Hence, the last number doesn't need checking.
# # Give the best-case and worst-case running times of selection sort in theta-notation.
# # #
# analysis
# c1-n, c2- n-1, c3- (n^2+n)/2, c4- (n-1)n/2, c5- (n-1)n/2, c6- (n-1)n/2, c7- n-1
### best-case when c3 is executed once like other statements in the loop with n-1.  c4,c5 and c6 is never executed. Therefore, best-case is n, n-1,n-1,n-1. Linear function of n
#### worst-case when go through every loops and statements.  n, n-1, (n^2+n)/2, (n-1)n/2, (n-1)n/2, (n-1)n/2, n-1


# 2.2-3
# worst case - checking every n element to compare with the search value.
# average case running time - n/2, worst case running time - n. Both of them are n

# 2.2-4
# the elements are pre-sorted then we can have a good base-case running time.


# merge sort from pseudo code to python
def merge(left, right):
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result


def merge_sort(A):
    if len(A) < 2:
        return A
    mid = len(A) // 2
    L = A[:mid]
    R = A[mid:]
    return merge(merge_sort(L), merge_sort(R))


print('merge sort')
print(merge_sort([5, 4, 8, 7, 1]))


# from pseudo code in the book
def merge2(A, p, q, r):
    n1 = q - p + 1
    n2 = r - q
    L, R = [], []

    for i in range(n1):
        L.append(A[p + i])
    for j in range(n2):
        R.append(A[q + j + 1])
    L.append(float('inf'))
    R.append(float('inf'))
    # print('p {}, q {}, r {}, n1 {}, n2 {}, L {}, R {}').format(p, q, r, n1, n2, L, R)
    i = j = 0
    for k in range(p, r + 1):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1


def merge_sort2(A, p, r):
    if p < r:
        q = (p + r) // 2  # mid
        # print('mid is q - {}, p - {}, r - {}').format(q, p, r)
        merge_sort2(A, p, q)  # A[p:q+1]
        # print('merge sort right')
        merge_sort2(A, q + 1, r)  # A[q+1+1:r]
        merge2(A, p, q, r)


A = [5, 4, 8, 7, 1]
merge_sort2(A, 0, len(A) - 1)
print(A)


# 2.3-1
# [3, 41, 52, 26, 38, 57, 9, 49]
# L[3, 41] . R[26, 52] . L[38, 57] . R[9, 49]
# L[3, 26, 41, 52] . R[9, 38,49, 57]
# [3, 9, 26, 38, 41, 49, 52, 57]

# 2.3-2
#

# 2.3-3
# refer to geogebra book CLRS

# 2.3-4
# refer to geogebra book CLRS

# 2.3-5

